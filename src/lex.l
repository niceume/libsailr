
/* *********** */
/* Definitions */
/* *********** */

/* References */
/* Introduction to Flex: https://web.eecs.utk.edu/~bvz/teaching/cs461Sp11/notes/flex/#states  */
/* Comments in Lex and Yacc: */
/* (ref.1) https://stackoverflow.com/questions/37266322/creating-comments-in-lex-and-yacc */
/* (ref.2) https://stackoverflow.com/questions/40564020/how-can-we-add-comments-in-flex-bison-source-code */

/* 1-1. Lines to be included at the beginning of generated scanner. */
%{
#include <string.h>
#include <ctype.h>

#include "parser_state.h"
#include "struct_string.h"
#include "node.h"

// LEX_RETURN(int c) works just in the sme way as calling return, but update parser_state's property.
static int
lex_return(parser_state *p, int c)
{
  p->lineno = p->tline;
  p->tline = yylineno;
  return c;
}

/* Generated by yacc. Variable values for tokens defined in parse.y. */
/* y.tab.h should be included after functions for nodes and struct_srings. */
#include "y.tab.h"

#define LEX_RETURN(c) return  lex_return(p, c)

/* lexerror is defined in subroutine section. */
/* But here you need prototypes to use in rules appropriately. */
extern void lexerror(parser_state* , char);

%}

/* 1-2. Options to be enabled in code */
/* Generated yylex()'s function prototype. (By default, no argument.)*/
%{
#define YY_DECL int yylex(YYSTYPE *lval, parser_state *p)
%}

/* Usually you do not need yywarp() function. */
%option noyywrap

/* Enable yylineno variable. */
%option yylineno

/* 2. Macros that are expanded in rules */

CHAR   [a-zA-Z_]|[\302-\337][\200-\277]|[\340-\357][\200-\277][\200-\277]|[\360-\367][\200-\277][\200-\277]|[\370-\373][\200-\277][\200-\277][\200-\277][\200-\277]|[\374-\375][\200-\277][\200-\277][\200-\277][\200-\277][\200-\277]
CHNUM  ({CHAR}|[0-9])
WORD {CHAR}{CHNUM}*

/* 3. (Start) states that can become active when BEGIN <state> is called in actions. */

%start  COMM COMMONE IFSTATE ELSESTATE

%%

	/***************/
	/* Rules            */
	/*                  */
	/* Rule priorities  */
	/* 1) The longest match is preferred. 2) Among rules which matched the same number of characters, the rule given first is preferred. . */
	/* (ref.) Sec5 Ambigous Source RUles in  http://dinosaur.compilertools.net/lex/index.html */
	/*                  */
	/* Operators in Lex */
	/* These should be escaped or enclosed with "". */
	/* " \ [ ] ^ - ? . * + | ( ) $ / { } % < > */
	/* **************** */

	/*  For comments */
"/*"					{ BEGIN COMM; };
<COMM>.*"*/"\n?		{ BEGIN INITIAL;};
<COMM>.+\n				{ };

"//"					{ BEGIN COMMONE ; };
<COMMONE>\n			{ BEGIN INITIAL ; };
<COMMONE>.*			{};

	/* Keywords for DATA Step */
if		{BEGIN IFSTATE; printf("IF STATE!\n"); LEX_RETURN( KEY_IF );}
else	{BEGIN ELSESTATE; printf("ELSE STATE!\n"); LEX_RETURN( KEY_ELSE );}
	/* Ignore \n once. */
<IFSTATE>"{"" "* {BEGIN INITIAL; LEX_RETURN('{') ;}
<IFSTATE>"{"" "*\n? {BEGIN INITIAL; LEX_RETURN('{') ;}
<IFSTATE>\n" "*"{"" "*\n?  {BEGIN INITIAL;LEX_RETURN('{') ;}
<IFSTATE>\n  {BEGIN INITIAL;}
	/* Ignore \n once. */
<ELSESTATE>"{"" "* {BEGIN INITIAL; LEX_RETURN('{') ;}
<ELSESTATE>"{"" "*\n? {BEGIN INITIAL; LEX_RETURN('{') ;}
<ELSESTATE>\n" "*"{"" "*\n?  {BEGIN INITIAL; LEX_RETURN('{') ;}
<ELSESTATE>\n  {BEGIN INITIAL;}

	/* Ignore complete space lines */
^[ \t]*\n					{};

	/* For operators */
"+"	LEX_RETURN( OP_PLUS );
"-"	LEX_RETURN( OP_SUB );
"*"	LEX_RETURN( OP_MULT );
"/"	LEX_RETURN( OP_DIV );
"%"	LEX_RETURN( OP_MOD );
"!"	{printf("FACTOR OPERATOR DETECTED!! \n"); LEX_RETURN( FACTOR );}
"^"	LEX_RETURN( OP_POWER );
"**"	LEX_RETURN( OP_POWER );

	/* For comparison */
"=="	LEX_RETURN( OP_EQ );
"!="	LEX_RETURN( OP_NEQ );
">"	LEX_RETURN( OP_GT );
"<"	LEX_RETURN( OP_LT );
">="	LEX_RETURN( OP_GE );
"<="	LEX_RETURN( OP_LE );

	/* For logical operators */
"and"	LEX_RETURN( AND );
"or"	LEX_RETURN( OR );
"&&"	LEX_RETURN( AND );
"||"	LEX_RETURN( OR );

	/* For assignment */
"<-"	LEX_RETURN( ASSIGN );
"="	LEX_RETURN( ASSIGN );

	/* For Parentheses and Blocks */
"("	LEX_RETURN( '(' );
")"	LEX_RETURN( ')' );
"{"	LEX_RETURN( '{' );
"}"	LEX_RETURN( '}' );

	/* For Macro */
"%{"	LEX_RETURN( PLCUR );
"%}"	LEX_RETURN( PRCUR );

	/* For list identities */
","	LEX_RETURN( COMMA );

	/* Identifier such as variable names, and function names */
{WORD}		{
	lval->id = 	((new_struct_string(yytext, yyleng))->buf ) ;
	LEX_RETURN( IDENT );
};

	/* Number */
([1-9][0-9]*)|0	{
	lval->nd = new_node_int(yytext);
	LEX_RETURN( LIT_NUM );
};

(([1-9][0-9]*)|0)\.[0-9]*	{
	lval->nd = new_node_double(yytext);
	LEX_RETURN( LIT_NUM );
};

	/* String literals */
	/* (ref.)  https://stackoverflow.com/questions/2039795/regular-expression-for-a-string-literal-in-flex-lex   */


\"([^\\\"]|\\.)*\"	{
	lval->str = new_struct_string(yytext, yyleng);
	LEX_RETURN( LIT_STR );
};

\'([^\\\']|\\.)*\'	{
	lval->str = new_struct_string(yytext, yyleng);
	LEX_RETURN( LIT_STR );
};

	/*  Terminators */
	/* Sequential terminators are dealt as a single terminator. */
[;\n]+	{
	LEX_RETURN( TERMIN );
};

	/* Spaces */
[ \t]	{ };

	/* Other characters */
. {
	char c = yytext[0];
	lexerror(p, c);
};

%%
/* ************* */
/* User Code     */
/* ************* */

extern int  yylineno;
void lexerror(parser_state* p, char c){
	fprintf(stderr, "%s:%d:lexical error", p->fname, yylineno);
	fprintf(stderr, "('%c').\n", c);
	exit(1);
}
